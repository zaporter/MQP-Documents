\chapter{Introduction}

% Starting a new programming job is similar at almost every company. The first week entails many meetings where senior engineers draw state diagrams on whiteboards while you rapidly take notes, you might also start diving into small sections of the codebase. Then, during the second and third week, you start to make small modifications to the codebase while trying to piece segments together. During these weeks, you're almost certainly concerned that some part of the codebase uses code you modified in ways that you dont expect. Finally, after a few months, you have gained an in-depth understanding of almost all parts of the codebase and are able to confidently modify and refactor significant sections of the codebase. 

Starting a new programming job is similar at almost every company. In the first week, you attend many meetings where senior engineers draw state diagrams on whiteboards while you take notes quickly and try to remember as much as possible. Then, during the second and third week, you make small modifications to the codebase while trying to piece segments together. During these weeks, you are almost certainly paranoid that some part of the codebase uses your modified code in ways you don't yet comprehend, or that your mental model of the code is wrong. It is only after a few months, that you have gained an in-depth understanding of almost all parts of the codebase and are able to confidently modify and refactor significant sections. This process varies slightly from company to company or from project to project, however the difficulty and large amount of time expended is universal. 

% In this paper, we introduce Explorant, a novel tool for code exploration that has been designed to improve the onboarding experience. Explorant allows users to quickly understand and relate the different components of a codebase without relying on the help of others. Explorant combines finite state machine (FSM) diagrams, source code, and gdb into one tightly integrated tool to allow the user to dive deep into a single concept or gain a glimpse of the entire program. We also designed Explorant to counter many common problems that current onboarding tools have. Namely, Explorant relies on the real execution of the program rather than a theoretical or outdated module, it is highly interactive and has a tight feedback loop, and it links directly to the code rather than the user having to map high level concepts to code.

In this paper, we introduce Explorant, a novel code exploration tool designed to improve the onboarding experience. Explorant allows users to quickly understand and relate to the different components of a codebase without relying on the time of senior engineers. To achieve this, we integrated finite state machine (FSM) diagrams, source code, and gdb into one tightly integrated tool, enabling users to easily delve into specific concepts or gain an overview of the entire program. 

In order to design Explorant, we first performed a case-study where we spent a week attempting to understand glibc's memory allocator (\begin{tt}malloc\end{tt}) with the current common tools for understanding a program. We chose to study \begin{tt}malloc\end{tt} because of its well thought out design which retains a large amount of complexity. During this process, we learned about the difficulties of using debuggers for understanding code flow, the difficulty that goes into having really detailed up to date documentation, how error handling code imposes a large mental burden on the programmer, and how easy it is to misunderstand how large chunks of code work together. This study provided us with the experience and knowledge neccessary to design a tool that helps with program-understanding

This lead us to design Explorant to address these problems and more. For example, Explorant relies on the actual execution of the program instead of a theoretical or outdated model, it is highly interactive and has a tight feedback loop, the programmer can choose to only pay attention to the happy path, and it directly links to the code, eliminating the need for users to map high-level concepts to code. 

In this paper, we present Explorant, a new code exploration tool that aims to enhance the onboarding experience. With Explorant, users can quickly understand and relate different components of a codebase without needing the assistance of senior engineers. We achieve this by integrating finite state machine (FSM) diagrams, source code, and gdb into a single, cohesive tool that enables users to easily delve into specific concepts or gain a broad overview of the entire program.

To design Explorant, we first conducted a case-study where we spent a week attempting to understand the glibc memory allocator (\begin{tt}malloc\end{tt}) using popular methodologies (source + complex IDE features + gdb + diagrams). We chose to study \begin{tt}malloc\end{tt} because of its complex yet well-thought-out design. During this process, we identified some of the biggest areas for improvement: the reality that debuggers are too implementation-focused for large-scale code flow understanding, the difficulty of maintaining detailed and up-to-date documentation, the mental burden of skimming error handling code, and the difficultiy of misunderstanding how large chunks of code work together. 

Based on our findings, we designed Explorant to address these problems and more. Explorant allows you to record a trace of a program, and then open up that trace to build a FSM diagram and view all of the source code. Explorant works primarily on the concept of events which are just annotated lines of source code that later become nodes in the FSM. These events can either be added via annotations in the source or by loading up the trace and then right clicking on the source line you are interested in. Once you add or edit an event, the FSM is updated live to show how this event relates to other nodes. Explorant even also allows you to click on any event and then open up gdb at any time during the execution where that event was run. These capabilities allow a programmer to easily dive deep into any individual section of the code while also building a high level understanding of the whole program.


