\chapter{Introduction}

% Starting a new programming job is similar at almost every company. The first week entails many meetings where senior engineers draw state diagrams on whiteboards while you rapidly take notes, you might also start diving into small sections of the codebase. Then, during the second and third week, you start to make small modifications to the codebase while trying to piece segments together. During these weeks, you're almost certainly concerned that some part of the codebase uses code you modified in ways that you dont expect. Finally, after a few months, you have gained an in-depth understanding of almost all parts of the codebase and are able to confidently modify and refactor significant sections of the codebase. 




Brooks's law famously states that ``adding manpower to a late software project makes it even later''\cite{onboarding-brooks}. He attributes this to what he calls the \textit{ramp-up} problem\cite{onboarding-ramp} wherein by adding a new developer you impose a burden on the rest of the team to educate them over the span of multiple months. Our industry experience lines up with this observation. We are deeply familiar with the standard first-week meetings with mentors drawing diagrams on whiteboards while the new developer rapidly takes notes. The new developer is then subject to multiple weeks wherein they are paranoid that they have misunderstood the stack or that some part of the stack was described wrong as they add new code. Our research shows that it often takes developers between three and nine months until they are fully ramped up\,\cite{onboarding-time}. We use the term \textit{onboarding} to describe this multi-month process of becoming an expert in an existing codebase.

In this report, we present Explorant, a code exploration tool designed to enhance and parallelize the onboarding experience. Explorant allows a developer to quickly understand and relate different components of a codebase based on the execution of a trace. With Explorant, senior engineers can annotate their code to produce diagrams that the new engineer can use as a stepping stone for further exploration. We achieve this by integrating state diagrams, source code, RR \cite{rr-site}, and GDB \cite{gdb} into a single cohesive tool that enables users to seamlessly delve into specific code paths or gain a broad overview of the entire program.

% To design Explorant, we first conducted a case-study where we spent a week attempting to understand the glibc memory allocator (\begin{tt}malloc\end{tt}) using popular methodologies (source + complex IDE features + gdb + diagrams). We chose to study \begin{tt}malloc\end{tt} because of its complex yet well-thought-out design. During this process, we identified some of the biggest areas for improvement: the reality that debuggers are too implementation-focused for large-scale code flow understanding, the difficulty of maintaining detailed and up-to-date documentation, the mental burden of skimming error handling code, and the difficultiy of misunderstanding how large chunks of code work together. 

% Based on our findings, we designed Explorant to address these problems and more. Explorant allows you to record a trace of a program, and then open up that trace to build a FSM diagram and view all of the source code. Explorant works primarily on the concept of events which are just annotated lines of source code that later become nodes in the FSM. These events can either be added via annotations in the source or by loading up the trace and then right clicking on the source line you are interested in. Once you add or edit an event, the FSM is updated live to show how this event relates to other nodes. Explorant even also allows you to click on any event and then open up gdb at any time during the execution where that event was run. These capabilities allow a programmer to easily dive deep into any individual section of the code while also building a high level understanding of the whole program.


