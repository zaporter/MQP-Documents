\chapter{Introduction}

% Starting a new programming job is similar at almost every company. The first week entails many meetings where senior engineers draw state diagrams on whiteboards while you rapidly take notes, you might also start diving into small sections of the codebase. Then, during the second and third week, you start to make small modifications to the codebase while trying to piece segments together. During these weeks, you're almost certainly concerned that some part of the codebase uses code you modified in ways that you dont expect. Finally, after a few months, you have gained an in-depth understanding of almost all parts of the codebase and are able to confidently modify and refactor significant sections of the codebase. 



Brook's law famously states that "adding manpower to a late software project makes it even later" \cite{onboarding-brooks}. He attributes this to what he calls the "ramp-up problem" \cite{onboarding-ramp} wherein by adding more developers you impose a huge burden on the rest of the team to educate them over the span of multiple months. Our industry experience lines up with this observation. We are deeply familiar with the hours of meetings with mentors drawing diagrams and rapidly taking notes. We are also familiar with the multiple weeks wherein the new developer is paranoid that they have either misunderstood the stack or that some part of the stack was described wrong as they add new code. In our experience, it can take up to a few months before this feeling starts to fade (depending on the complexity of the software). In literature, this phenomeon is often called the "ramp-up problem" \cite{onboarding-ramp} however I will refer to it with the broader term: onboarding. Onboarding varies slightly from company to company or from project to project, and the large efford and time commitment from onboarding will likely never be fully eliminated we may try.

In this paper, we present Explorant, a new code exploration tool that aims to enhance the onboarding experience. With Explorant, senior engineers can annotate their code to produce diagrams that the new engineer can use as a stepping stone for further exploration. Explorant allows developer to quickly understand and relate different components of a codebase based on the execution of a trace rather than the expert knowledge of a senior engineer. We achieve this by integrating finite state machine (FSM) diagrams, source code, and gdb into a single cohesive tool that enables users to easily delve into specific concepts or gain a broad overview of the entire program.

% To design Explorant, we first conducted a case-study where we spent a week attempting to understand the glibc memory allocator (\begin{tt}malloc\end{tt}) using popular methodologies (source + complex IDE features + gdb + diagrams). We chose to study \begin{tt}malloc\end{tt} because of its complex yet well-thought-out design. During this process, we identified some of the biggest areas for improvement: the reality that debuggers are too implementation-focused for large-scale code flow understanding, the difficulty of maintaining detailed and up-to-date documentation, the mental burden of skimming error handling code, and the difficultiy of misunderstanding how large chunks of code work together. 

% Based on our findings, we designed Explorant to address these problems and more. Explorant allows you to record a trace of a program, and then open up that trace to build a FSM diagram and view all of the source code. Explorant works primarily on the concept of events which are just annotated lines of source code that later become nodes in the FSM. These events can either be added via annotations in the source or by loading up the trace and then right clicking on the source line you are interested in. Once you add or edit an event, the FSM is updated live to show how this event relates to other nodes. Explorant even also allows you to click on any event and then open up gdb at any time during the execution where that event was run. These capabilities allow a programmer to easily dive deep into any individual section of the code while also building a high level understanding of the whole program.


